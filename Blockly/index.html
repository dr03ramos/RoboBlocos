<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>RoboBlocos - Visual Programming</title>
    <script src="lib/blockly_compressed.js"></script>
    <script src="lib/blocks_compressed.js"></script>
    <script src="custom/nqc-generator.js"></script>
    <style>
        body {
            background-color: #fff;
            font-family: sans-serif;
            margin: 0;
            padding: 0;
        }

        #blocklyDiv {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="blocklyDiv"></div>

    <xml id="toolbox" style="display: none">
        <category name="Carregando...">
            <block type="nqc_ligar_motor"></block>
        </category>
    </xml>

    <script src="custom/nqc-blocks.js"></script>
    <script>
        /**
         * Atualiza a toolbox dinamicamente com base nos blocos no workspace
         */
        function updateDynamicToolbox() {
            console.log('[updateDynamicToolbox] Atualizando toolbox...');
            
            // Coletar todas as tarefas nomeadas
            var taskBlocks = workspace.getBlocksByType('nqc_tarefa_nomeada', false);
            var tasks = [];
            for (var i = 0; i < taskBlocks.length; i++) {
                var taskName = taskBlocks[i].getFieldValue('NOME');
                if (taskName && taskName.trim() !== '') {
                    tasks.push(taskName);
                }
            }
            
            // Coletar todas as variáveis declaradas
            var varBlocks = workspace.getBlocksByType('nqc_variavel_recebe', false);
            var variables = [];
            var variableSet = {}; // Para evitar duplicatas
            for (var i = 0; i < varBlocks.length; i++) {
                var varName = varBlocks[i].getFieldValue('VAR');
                if (varName && varName.trim() !== '' && !variableSet[varName]) {
                    variables.push(varName);
                    variableSet[varName] = true;
                }
            }
            
            // Gerar um nome único para nova tarefa (evitar duplicação)
            var suggestedTaskName = 'minhaTarefa';
            var taskNameIndex = 1;
            while (tasks.indexOf(suggestedTaskName) !== -1) {
                suggestedTaskName = 'minhaTarefa' + taskNameIndex;
                taskNameIndex++;
            }
            
            console.log('[updateDynamicToolbox] Tarefas encontradas:', tasks);
            console.log('[updateDynamicToolbox] Variáveis encontradas:', variables);
            console.log('[updateDynamicToolbox] Nome sugerido para nova tarefa:', suggestedTaskName);
            
            // Criar XML da toolbox dinamicamente
            var toolboxXml = '<xml id="toolbox">';
            
            // Categoria Motores
            toolboxXml += '<category name="Motores" colour="210">';
            toolboxXml += '<block type="nqc_ligar_motor"></block>';
            toolboxXml += '<block type="nqc_ligar_motor_com_potencia">';
            toolboxXml += '<value name="POTENCIA"><shadow type="nqc_percentual"><field name="NUM">100</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_define_sentido"></block>';
            toolboxXml += '<block type="nqc_define_potencia_percent">';
            toolboxXml += '<value name="POTENCIA"><shadow type="nqc_percentual"><field name="NUM">50</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_desligar_motor"></block>';
            toolboxXml += '<block type="nqc_toca_som"></block>';
            toolboxXml += '</category>';
            
            // Categoria Sensores
            toolboxXml += '<category name="Sensores" colour="140">';
            toolboxXml += '<block type="nqc_define_sensor_toque"></block>';
            toolboxXml += '<block type="nqc_define_sensor_luz"></block>';
            toolboxXml += '<block type="nqc_define_sensor_rotacao"></block>';
            toolboxXml += '<block type="nqc_define_sensor_temperatura"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_toque"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_luz"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_rotacao"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_temperatura"></block>';
            toolboxXml += '</category>';
            
            // Categoria Controles
            toolboxXml += '<category name="Controles" colour="90">';
            toolboxXml += '<block type="nqc_espera_segundos">';
            toolboxXml += '<value name="SECONDS"><shadow type="nqc_numero"><field name="NUM">1</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_espera_ate_que"></block>';
            toolboxXml += '<block type="nqc_repita_vezes">';
            toolboxXml += '<value name="TIMES"><shadow type="nqc_numero"><field name="NUM">10</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_repita_infinitamente"></block>';
            toolboxXml += '<block type="nqc_repita_ate_que"></block>';
            toolboxXml += '</category>';
            
            // Categoria Variáveis (DINÂMICA)
            toolboxXml += '<category name="Variáveis" colour="0">';
            toolboxXml += '<block type="nqc_variavel_recebe"></block>';
            if (variables.length == 0) {
                toolboxXml += '<block type="nqc_valor_variavel"><field name="VAR">x</field></block>';
            } else {
                // Adicionar blocos para cada variável existente
                for (var i = 0; i < variables.length; i++) {
                    toolboxXml += '<block type="nqc_valor_variavel">';
                    toolboxXml += '<field name="VAR">' + variables[i] + '</field>';
                    toolboxXml += '</block>';
                }
            }
            toolboxXml += '</category>';
            
            // Categoria Matemática
            toolboxXml += '<category name="Matemática" colour="330">';
            toolboxXml += '<block type="nqc_numero"><field name="NUM">0</field></block>';
            toolboxXml += '<block type="nqc_operacao_matematica"></block>';
            toolboxXml += '</category>';
            
            // Categoria Lógica
            toolboxXml += '<category name="Lógica" colour="290">';
            toolboxXml += '<block type="nqc_comparacao"></block>';
            toolboxXml += '<block type="nqc_operacao_logica"></block>';
            toolboxXml += '<block type="nqc_contrario"></block>';
            toolboxXml += '<block type="nqc_booleano"></block>';
            toolboxXml += '</category>';
            
            // Categoria Condicionais
            toolboxXml += '<category name="Condicionais" colour="260">';
            toolboxXml += '<block type="nqc_se_faca"></block>';
            toolboxXml += '<block type="nqc_se_faca_senao"></block>';
            toolboxXml += '</category>';
            
            // Categoria Tarefas (DINÂMICA)
            toolboxXml += '<category name="Tarefas" colour="170">';
            toolboxXml += '<block type="nqc_tarefa_principal"></block>';
            // Bloco "tarefa nomeada" com nome sugerido único
            toolboxXml += '<block type="nqc_tarefa_nomeada"><field name="NOME">' + suggestedTaskName + '</field></block>';
            
            if (tasks.length == 0) {
                // Se não há tarefas, mostrar bloco genérico
                toolboxXml += '<block type="nqc_executar_tarefa"><field name="NOME">minhaTarefa</field></block>';
                toolboxXml += '<block type="nqc_interromper_tarefa"><field name="NOME">minhaTarefa</field></block>';
            } else {
                // Adicionar blocos para cada tarefa existente
                for (var i = 0; i < tasks.length; i++) {
                    toolboxXml += '<block type="nqc_executar_tarefa">';
                    toolboxXml += '<field name="NOME">' + tasks[i] + '</field>';
                    toolboxXml += '</block>';
                    toolboxXml += '<block type="nqc_interromper_tarefa">';
                    toolboxXml += '<field name="NOME">' + tasks[i] + '</field>';
                    toolboxXml += '</block>';
                }
            }
            toolboxXml += '</category>';
            
            toolboxXml += '</xml>';
            
            // Atualizar a toolbox
            var toolboxDom = Blockly.utils.xml.textToDom(toolboxXml);
            workspace.updateToolbox(toolboxDom);
            
            console.log('[updateDynamicToolbox] Toolbox atualizada com sucesso');
        }

        // Inicializar workspace do Blockly
        var workspace = Blockly.inject('blocklyDiv', {
            toolbox: document.getElementById('toolbox'),
            grid: {
                spacing: 25,
                length: 3,
                colour: '#ccc',
                snap: true
            },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0,
                maxScale: 3,
                minScale: 0.3,
                scaleSpeed: 1.2
            },
            trashcan: true,
            maxInstances: {
                'nqc_tarefa_principal': 1  // Limitar a apenas 1 bloco de tarefa principal
            }
        });

        updateDynamicToolbox();

        // Notificar C# que o Blockly está pronto
        console.log('[Blockly] Workspace inicializado e pronto');
        if (window.chrome && window.chrome.webview) {
            window.chrome.webview.postMessage(JSON.stringify({
                type: 'blocklyReady'
            }));
        }

        // Gerar código NQC a partir dos blocos
        function generateCode() {
            console.log('[generateCode] Iniciando geração de código NQC');
            
            if (!nqc || !nqc.nqcGenerator) {
                console.error('[generateCode] NQC generator não disponível');
                return '';
            }

            try {
                var code = nqc.nqcGenerator.workspaceToCode(workspace);
                console.log('[generateCode] Código NQC gerado:', code ? code.substring(0, 100) + '...' : 'vazio');

                // Enviar código para a aplicação C#
                if (window.chrome && window.chrome.webview) {
                    console.log('[generateCode] Enviando mensagem para C#: codeGenerated');
                    window.chrome.webview.postMessage(JSON.stringify({
                        type: 'codeGenerated',
                        code: code
                    }));
                } else {
                    console.warn('[generateCode] window.chrome.webview não disponível');
                }

                return code;
            } catch (error) {
                console.error('[generateCode] Erro ao gerar código:', error);
                return '';
            }
        }

        // Executar o código gerado (não aplicável para NQC, mas mantido para compatibilidade)
        function runCode() {
            var code = generateCode();
            console.log('[runCode] Código gerado (não executável no navegador)');
        }

        // Variável para controlar debounce da atualização da toolbox
        var toolboxUpdateTimeout = null;

        // Gerar código automaticamente quando o workspace mudar
        workspace.addChangeListener(function (event) {
            console.log('[workspace.addChangeListener] Evento:', event.type);

            if (event.type === Blockly.Events.BLOCK_CHANGE ||
                event.type === Blockly.Events.BLOCK_CREATE ||
                event.type === Blockly.Events.BLOCK_DELETE ||
                event.type === Blockly.Events.BLOCK_MOVE) {

                console.log('[workspace.addChangeListener] Gerando código e notificando C#...');
                generateCode();
                
                // Atualizar toolbox com debounce (evitar múltiplas atualizações seguidas)
                if (event.type === Blockly.Events.BLOCK_CHANGE ||
                    event.type === Blockly.Events.BLOCK_CREATE ||
                    event.type === Blockly.Events.BLOCK_DELETE) {
                    
                    // Cancelar timeout anterior se existir
                    if (toolboxUpdateTimeout) {
                        clearTimeout(toolboxUpdateTimeout);
                    }
                    
                    // Agendar atualização da toolbox após 500ms
                    toolboxUpdateTimeout = setTimeout(function() {
                        updateDynamicToolbox();
                    }, 500);
                }
            }
        });

        // Carregar workspace a partir de XML
        function loadWorkspaceFromXml(xmlText) {
            console.log('[loadWorkspaceFromXml] Iniciando carregamento...');
            console.log('[loadWorkspaceFromXml] XML recebido:', xmlText ? xmlText.substring(0, 100) + '...' : 'vazio');

            try {
                // Desabilitar eventos durante o carregamento para evitar marcação como modificado
                Blockly.Events.disable();

                workspace.clear();
                console.log('[loadWorkspaceFromXml] Workspace limpo');

                if (xmlText && xmlText.trim() !== '') {
                    console.log('[loadWorkspaceFromXml] Convertendo XML para DOM...');
                    var xml = Blockly.utils.xml.textToDom(xmlText);
                    console.log('[loadWorkspaceFromXml] XML convertido, carregando no workspace...');
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    console.log('[loadWorkspaceFromXml] Workspace carregado com sucesso!');
                    console.log('[loadWorkspaceFromXml] Blocos carregados:', workspace.getAllBlocks(false).length);
                } else {
                    console.log('[loadWorkspaceFromXml] XML vazio, workspace permanece limpo');
                }

                // Reabilitar eventos
                Blockly.Events.enable();
                
                // Atualizar toolbox após carregar workspace
                updateDynamicToolbox();

                return true;
            } catch (e) {
                console.error('[loadWorkspaceFromXml] Erro ao carregar workspace:', e);
                console.error('[loadWorkspaceFromXml] Stack trace:', e.stack);

                // Reabilitar eventos mesmo em caso de erro
                Blockly.Events.enable();

                return false;
            }
        }

        // Função para obter o código NQC gerado (chamada do C#)
        function getGeneratedCode() {
            console.log('[getGeneratedCode] Função chamada');
            return generateCode();
        }

        console.log('[Blockly] Workspace inicializado e pronto');
    </script>
</body>
</html>
