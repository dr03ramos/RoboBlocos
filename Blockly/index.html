<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>RoboBlocos - Visual Programming</title>

    <!-- Bibliotecas Blockly -->
    <script src="lib/blockly_compressed.js"></script>
    <script src="lib/blocks_compressed.js"></script>

    <!-- 1. PRIMEIRO: Gerador base (classe NqcGenerator) -->
    <script src="custom/nqc-generator.js"></script>

    <!-- 2. SEGUNDO: Definições de blocos -->
    <script src="custom/nqc-blocks-definitions.js"></script>

    <!-- 3. TERCEIRO: Geradores de blocos customizados -->
    <script src="custom/nqc-blocks-generators.js"></script>

    <style>
        body {
            background-color: #fff;
            font-family: sans-serif;
            margin: 0;
            padding: 0;
        }

        #blocklyDiv {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="blocklyDiv"></div>

    <xml id="toolbox" style="display: none">
        <category name="Carregando...">
            <block type="nqc_ligar_motor"></block>
        </category>
    </xml>

    <script>
        /**
         * Altera a nomenclatura dos blocos entre 'iniciante' e 'tecnico'
         * @param {string} modo - 'iniciante' ou 'tecnico'
         */
        function alterarNomenclatura(modo) {
            console.log('[alterarNomenclatura] Alterando para:', modo);

            // Validar modo
            if (modo !== 'iniciante' && modo !== 'tecnico' && modo !== 'técnico') {
                console.error('[alterarNomenclatura] Modo inválido:', modo);
                return;
            }

            // Normalizar "técnico" para "tecnico" (sem acento)
            if (modo === 'técnico') {
                modo = 'tecnico';
            }

            // Atualizar variável global
            nomenclaturaAtual = modo;

            // 1. Atualizar blocos no workspace
            var todosOsBlocos = workspace.getAllBlocks(false);
            console.log('[alterarNomenclatura] Atualizando', todosOsBlocos.length, 'blocos');

            todosOsBlocos.forEach(function(block) {
                atualizarTextosBloco(block);
            });

            // 2. Forçar re-render de todos os blocos
            workspace.getAllBlocks(false).forEach(function(block) {
                block.render();
            });

            // 3. Atualizar toolbox
            updateDynamicToolbox();

            console.log('[alterarNomenclatura] Concluído');
        }

        /**
         * Atualiza os textos de um bloco específico baseado na nomenclatura atual
         * @param {Blockly.Block} block - Bloco a ser atualizado
         */
        function atualizarTextosBloco(block) {
            if (!block || !block.type) {
                return;
            }

            var blockType = block.type;

            // Lista de blocos que precisam ser atualizados
            var blocksToUpdate = [
                'nqc_ligar_motor_com_potencia',
                'nqc_ligar_motor',
                'nqc_desligar_motor',
                'nqc_define_potencia_percent',
                'nqc_define_sentido',
                'nqc_toca_som',
                'nqc_define_sensor_toque',
                'nqc_define_sensor_luz',
                'nqc_define_sensor_rotacao',
                'nqc_define_sensor_temperatura',
                'nqc_valor_sensor_toque',
                'nqc_valor_sensor_luz',
                'nqc_valor_sensor_rotacao',
                'nqc_valor_sensor_temperatura',
                'nqc_espera_segundos',
                'nqc_espera_ate_que',
                'nqc_repita_vezes',
                'nqc_repita_infinitamente',
                'nqc_repita_ate_que',
                'nqc_variavel_recebe',
                'nqc_valor_variavel',
                'nqc_contrario',
                'nqc_se_faca',
                'nqc_se_faca_senao',
                'nqc_tarefa_principal',
                'nqc_tarefa_nomeada',
                'nqc_executar_tarefa',
                'nqc_interromper_tarefa'
            ];

            // Se o bloco não está na lista de blocos a serem atualizados, ignorar
            if (blocksToUpdate.indexOf(blockType) === -1) {
                return;
            }

            // Obter novo texto baseado na nomenclatura atual
            var novoTexto = getTextoBloco(blockType);

            // Se não há texto para este bloco, ignorar
            if (!novoTexto) {
                return;
            }

            // Percorrer todos os inputs do bloco
            for (var i = 0; i < block.inputList.length; i++) {
                var input = block.inputList[i];

                // Percorrer todos os fields do input
                for (var j = 0; j < input.fieldRow.length; j++) {
                    var field = input.fieldRow[j];

                    // Se for um campo de texto (label) e for o primeiro do primeiro input
                    if (field instanceof Blockly.FieldLabel && i === 0 && j === 0) {
                        // Atualizar apenas o primeiro label (título do bloco)
                        field.setValue(novoTexto);
                        return; // Sair após atualizar o primeiro label
                    }
                }
            }
        }

        /**
         * Atualiza a toolbox dinamicamente com base nos blocos no workspace
         */
        function updateDynamicToolbox() {
            console.log('[updateDynamicToolbox] Iniciando atualização da toolbox...');

            // Coletar todas as tarefas nomeadas
            var taskBlocks = workspace.getBlocksByType('nqc_tarefa_nomeada', false);
            var tasks = [];
            for (var i = 0; i < taskBlocks.length; i++) {
                var taskName = taskBlocks[i].getFieldValue('NOME');
                if (taskName && taskName.trim() !== '') {
                    tasks.push(taskName);
                }
            }

            // Coletar todas as variáveis declaradas
            var varBlocks = workspace.getBlocksByType('nqc_variavel_recebe', false);
            var variables = [];
            var variableSet = {}; // Para evitar duplicatas
            for (var i = 0; i < varBlocks.length; i++) {
                var varName = varBlocks[i].getFieldValue('VAR');
                if (varName && varName.trim() !== '' && !variableSet[varName]) {
                    variables.push(varName);
                    variableSet[varName] = true;
                }
            }

            // Gerar um nome único para nova tarefa (evitar duplicação)
            var suggestedTaskName = 'minhaTarefa';
            var taskNameIndex = 1;
            while (tasks.indexOf(suggestedTaskName) !== -1) {
                suggestedTaskName = 'minhaTarefa' + taskNameIndex;
                taskNameIndex++;
            }

            // Criar XML da toolbox dinamicamente
            var toolboxXml = '<xml id="toolbox">';

            // Categoria Motores
            toolboxXml += '<category name="Motores" colour="210">';
            toolboxXml += '<block type="nqc_ligar_motor"></block>';
            toolboxXml += '<block type="nqc_ligar_motor_com_potencia">';
            toolboxXml += '<value name="POTENCIA"><shadow type="nqc_percentual"><field name="NUM">100</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_define_sentido"></block>';
            toolboxXml += '<block type="nqc_define_potencia_percent">';
            toolboxXml += '<value name="POTENCIA"><shadow type="nqc_percentual"><field name="NUM">50</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_desligar_motor"></block>';
            toolboxXml += '<block type="nqc_toca_som"></block>';
            toolboxXml += '</category>';

            // Categoria Sensores
            toolboxXml += '<category name="Sensores" colour="140">';
            toolboxXml += '<block type="nqc_define_sensor_toque"></block>';
            toolboxXml += '<block type="nqc_define_sensor_luz"></block>';
            toolboxXml += '<block type="nqc_define_sensor_rotacao"></block>';
            toolboxXml += '<block type="nqc_define_sensor_temperatura"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_toque"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_luz"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_rotacao"></block>';
            toolboxXml += '<block type="nqc_valor_sensor_temperatura"></block>';
            toolboxXml += '</category>';

            // Categoria Controles
            toolboxXml += '<category name="Controles" colour="90">';
            toolboxXml += '<block type="nqc_espera_segundos">';
            toolboxXml += '<value name="SECONDS"><shadow type="nqc_numero"><field name="NUM">1</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_espera_ate_que"></block>';
            toolboxXml += '<block type="nqc_repita_vezes">';
            toolboxXml += '<value name="TIMES"><shadow type="nqc_numero"><field name="NUM">10</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_repita_infinitamente"></block>';
            toolboxXml += '<block type="nqc_repita_ate_que"></block>';
            toolboxXml += '</category>';

            // Categoria Variáveis (DINÂMICA)
            toolboxXml += '<category name="Variáveis" colour="0">';
            toolboxXml += '<block type="nqc_variavel_recebe"></block>';
            if (variables.length == 0) {
                toolboxXml += '<block type="nqc_valor_variavel"><field name="VAR">x</field></block>';
            } else {
                // Adicionar blocos para cada variável existente
                for (var i = 0; i < variables.length; i++) {
                    toolboxXml += '<block type="nqc_valor_variavel">';
                    toolboxXml += '<field name="VAR">' + variables[i] + '</field>';
                    toolboxXml += '</block>';
                }
            }
            toolboxXml += '</category>';

            // Categoria Matemática
            toolboxXml += '<category name="Matemática" colour="330">';
            toolboxXml += '<block type="nqc_numero"><field name="NUM">0</field></block>';
            toolboxXml += '<block type="nqc_operacao_matematica">';
            toolboxXml += '<value name="A"><shadow type="nqc_numero"><field name="NUM">0</field></shadow></value>';
            toolboxXml += '<value name="B"><shadow type="nqc_numero"><field name="NUM">0</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '</category>';

            // Categoria Lógica
            toolboxXml += '<category name="Lógica" colour="290">';
            toolboxXml += '<block type="nqc_comparacao">';
            toolboxXml += '<value name="A"><shadow type="nqc_numero"><field name="NUM">0</field></shadow></value>';
            toolboxXml += '<value name="B"><shadow type="nqc_numero"><field name="NUM">0</field></shadow></value>';
            toolboxXml += '</block>';
            toolboxXml += '<block type="nqc_operacao_logica"></block>';
            toolboxXml += '<block type="nqc_contrario"></block>';
            toolboxXml += '<block type="nqc_booleano"></block>';
            toolboxXml += '</category>';

            // Categoria Condicionais
            toolboxXml += '<category name="Condicionais" colour="260">';
            toolboxXml += '<block type="nqc_se_faca"></block>';
            toolboxXml += '<block type="nqc_se_faca_senao"></block>';
            toolboxXml += '</category>';

            // Categoria Tarefas (DINÂMICA)
            toolboxXml += '<category name="Tarefas" colour="170">';
            toolboxXml += '<block type="nqc_tarefa_principal"></block>';
            // Bloco "tarefa nomeada" com nome sugerido único
            toolboxXml += '<block type="nqc_tarefa_nomeada"><field name="NOME">' + suggestedTaskName + '</field></block>';

            if (tasks.length == 0) {
                // Se não há tarefas, mostrar bloco genérico
                toolboxXml += '<block type="nqc_executar_tarefa"><field name="NOME">minhaTarefa</field></block>';
                toolboxXml += '<block type="nqc_interromper_tarefa"><field name="NOME">minhaTarefa</field></block>';
            } else {
                // Adicionar blocos para cada tarefa existente
                for (var i = 0; i < tasks.length; i++) {
                    toolboxXml += '<block type="nqc_executar_tarefa">';
                    toolboxXml += '<field name="NOME">' + tasks[i] + '</field>';
                    toolboxXml += '</block>';
                    toolboxXml += '<block type="nqc_interromper_tarefa">';
                    toolboxXml += '<field name="NOME">' + tasks[i] + '</field>';
                    toolboxXml += '</block>';
                }
            }
            toolboxXml += '</category>';

            toolboxXml += '</xml>';

            Blockly.utils.colour.setHsvSaturation(0.6);
            Blockly.utils.colour.setHsvValue(0.65);

            // Atualizar a toolbox
            var toolboxDom = Blockly.utils.xml.textToDom(toolboxXml);
            workspace.updateToolbox(toolboxDom);

            console.log('[updateDynamicToolbox] Toolbox atualizada com sucesso');
        }

        // Inicializar workspace do Blockly
        var workspace = Blockly.inject('blocklyDiv', {
            toolbox: document.getElementById('toolbox'),
            grid: {
                spacing: 25,
                length: 3,
                colour: '#ccc',
                snap: true
            },
            zoom: {
                controls: true,
                wheel: true,
                startScale: 1.0,
                maxScale: 3,
                minScale: 0.3,
                scaleSpeed: 1.2
            },
            trashcan: true,
            maxInstances: {
                'nqc_tarefa_principal': 1  // Limitar a apenas 1 bloco de tarefa principal
            }
        });

        updateDynamicToolbox();

        // Notificar C# que o Blockly está pronto
        console.log('[Blockly] Workspace inicializado e pronto');
        if (window.chrome && window.chrome.webview) {
            window.chrome.webview.postMessage(JSON.stringify({
                type: 'blocklyReady'
            }));
        }

        // Gerar código NQC a partir dos blocos
        function generateCode() {
            console.log('[generateCode] Iniciando geração de código NQC');

            if (!nqc || !nqc.nqcGenerator) {
                console.error('[generateCode] NQC generator não disponível');
                return '';
            }

            try {
                var code = nqc.nqcGenerator.workspaceToCode(workspace);
                console.log('[generateCode] Código NQC gerado:', code ? code.substring(0, 100) + '...' : 'vazio');

                // Enviar código para a aplicação C#
                if (window.chrome && window.chrome.webview) {
                    console.log('[generateCode] Enviando mensagem para C#: codeGenerated');
                    window.chrome.webview.postMessage(JSON.stringify({
                        type: 'codeGenerated',
                        code: code
                    }));
                } else {
                    console.warn('[generateCode] window.chrome.webview não disponível');
                }

                return code;
            } catch (error) {
                console.error('[generateCode] Erro ao gerar código:', error);
                return '';
            }
        }

        // Executar o código gerado (não aplicável para NQC, mas mantido para compatibilidade)
        function runCode() {
            var code = generateCode();
            console.log('[runCode] Código gerado (não executável no navegador)');
        }

        // Variável para controlar debounce da atualização da toolbox
        var toolboxUpdateTimeout = null;

        // Gerar código automaticamente quando o workspace mudar
        workspace.addChangeListener(function (event) {
            console.log('[workspace.addChangeListener] Evento:', event.type);

            if (event.type === Blockly.Events.BLOCK_CHANGE ||
                event.type === Blockly.Events.BLOCK_CREATE ||
                event.type === Blockly.Events.BLOCK_DELETE ||
                event.type === Blockly.Events.BLOCK_MOVE) {

                console.log('[workspace.addChangeListener] Gerando código e notificando C#...');
                generateCode();

                // Atualizar toolbox com debounce (evitar múltiplas atualizações seguidas)
                if (event.type === Blockly.Events.BLOCK_CHANGE ||
                    event.type === Blockly.Events.BLOCK_CREATE ||
                    event.type === Blockly.Events.BLOCK_DELETE) {

                    // Cancelar timeout anterior se existir
                    if (toolboxUpdateTimeout) {
                        clearTimeout(toolboxUpdateTimeout);
                    }

                    // Agendar atualização da toolbox após 500ms
                    toolboxUpdateTimeout = setTimeout(function() {
                        updateDynamicToolbox();
                    }, 500);
                }
            }
        });

        // Carregar workspace a partir de XML
        function loadWorkspaceFromXml(xmlText) {
            console.log('[loadWorkspaceFromXml] Iniciando carregamento...');
            console.log('[loadWorkspaceFromXml] XML recebido:', xmlText ? xmlText.substring(0, 100) + '...' : 'vazio');

            try {
                // Desabilitar eventos durante o carregamento para evitar marcação como modificado
                Blockly.Events.disable();

                workspace.clear();
                console.log('[loadWorkspaceFromXml] Workspace limpo');

                if (xmlText && xmlText.trim() !== '') {
                    console.log('[loadWorkspaceFromXml] Convertendo XML para DOM...');
                    var xml = Blockly.utils.xml.textToDom(xmlText);
                    console.log('[loadWorkspaceFromXml] XML convertido, carregando no workspace...');
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    console.log('[loadWorkspaceFromXml] Workspace carregado com sucesso!');
                    console.log('[loadWorkspaceFromXml] Blocos carregados:', workspace.getAllBlocks(false).length);
                } else {
                    console.log('[loadWorkspaceFromXml] XML vazio, workspace permanece limpo');
                }

                // Reabilitar eventos
                Blockly.Events.enable();

                // Atualizar toolbox após carregar workspace
                updateDynamicToolbox();

                return true;
            } catch (e) {
                console.error('[loadWorkspaceFromXml] Erro ao carregar workspace:', e);
                console.error('[loadWorkspaceFromXml] Stack trace:', e.stack);

                // Reabilitar eventos mesmo em caso de erro
                Blockly.Events.enable();

                return false;
            }
        }

        // Função para obter o código NQC gerado (chamada do C#)
        function getGeneratedCode() {
            console.log('[getGeneratedCode] Função chamada');
            return generateCode();
        }

        console.log('[Blockly] Workspace inicializado e pronto');
    </script>
</body>
</html>
